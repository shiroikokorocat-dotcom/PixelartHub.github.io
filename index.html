<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Select a Character</title>
    <link rel="stylesheet" href="style.css">
    <!-- Favicon real -->
    <link rel="icon" type="image/x-icon" href="assets/src/favicon.ico">
    <link rel="shortcut icon" href="assets/src/favicon.ico">
</head>
<body>
    <div id="loading-screen" role="dialog" aria-modal="true" aria-label="Cargando">
        <div class="loader-wrap">
            <div class="loader-logo" aria-hidden="true">
                <!-- 5 carriles con direcciones alternadas -->
        <div class="word-lane ltr"  style="top: 6px;">
                    <div class="scroll">
                        <span class="content">|- Hola, te doy las gracias por probar esta pagina experimental, 
                            la hice ya que disponía de tiempo y quería aprovechar de exponer el arte que  
                            hago de una forma cómoda y dar los créditos a las personas en la que me baso  
                            para este pasa tiempo -
                        </span>
                    </div>
                </div>
        <div class="word-lane rtl"  style="top: 34px;">
                    <div class="scroll">
            <span class="content"> Loading pixel art • Preparing animations • Applying theme •
                            Calculating color palettes • Loading statistics • Searching for links •
                        </span>
                    </div>
                </div>
        <div class="word-lane ltr"  style="top: 62px;">
                    <div class="scroll">
                        <span class="content">- Hello, thank you for trying out this experimental page. 
                            I made it because I had some free time and wanted to take advantage of it to showcase the art I  
                            create in a convenient way and give credit to the people who inspire me  
                            in this hobby -
                        </span>
                    </div>
                </div>
        <div class="word-lane rtl"  style="top: 90px;">
                    <div class="scroll">
                        <span class="content"> Cargando el pixelart • Preparando animaciones • Aplicando tema •
                            Calculando paletas de colores • Cargando estadisticas • Buscando enlaces •
                        </span>
                    </div>
                </div>
            </div>
            <div class="progress" aria-label="Loading progress">
                <div class="progress-track">
                    <div class="progress-line" id="progress-line" style="width:0%"></div>
                </div>
            </div>
            <div class="loader-text-frame">
                <div class="loader-text" id="loader-text" aria-live="polite" aria-atomic="true">
                    Loading<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span>
                </div>
            </div>
            <button id="loader-start" class="loader-cta hidden" type="button" aria-label="Start">
                Start
            </button>
        </div>
    </div>
    <div id="fondo-mosaico"></div>
    <canvas id="nubes-canvas" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:0;pointer-events:none;"></canvas>
    <h1>Select a<br>Character</h1>
    <div id="canvas-container">
        <canvas id="pixelart-canvas"></canvas>
    </div>
    <div id="info-panel" class="hidden">
    <button id="panel-close" class="panel-close" type="button" aria-label="Cerrar">✕</button>
        <div class="info-content">
            <div class="info-left">
                <img id="segment-preview" alt="Vista previa" />
                <div id="palette" class="palette">
                    <div class="palette-title">Palette</div>
                    <div id="color-palette" class="palette-swatches"></div>
                </div>
            </div>
            <div class="divider" aria-hidden="true"><span class="divider-rot" aria-hidden="true"></span></div>
            <div class="info-right">
                <div class="header">
                    <h2 id="personaje-nombre"></h2>
                </div>
                <div class="profile">
                    <img id="pfp-image" alt="Perfil" />
                </div>
                <div class="divider-h" aria-hidden="true"></div>
                <div id="stats" class="stats">
                    <div class="stats-title">Stats:</div>
                </div>
                <div class="meta">
                    <div id="social-links">
                        <div class="social-row"><span class="site-label">X</span><a id="link-x" class="social hidden" href="#" target="_blank" rel="noopener"></a></div>
                        <div class="social-row"><span class="site-label">VG</span><a id="link-vgen" class="social hidden" href="#" target="_blank" rel="noopener"></a></div>
                        <div class="social-row"><span class="site-label">KF</span><a id="link-kofi" class="social hidden" href="#" target="_blank" rel="noopener"></a></div>
                        <div class="social-row"><span class="site-label">YT</span><a id="link-youtube" class="social hidden" href="#" target="_blank" rel="noopener"></a></div>
                        <div class="social-row"><span class="site-label">TTV</span><a id="link-twitch" class="social hidden" href="#" target="_blank" rel="noopener"></a></div>
                           <div class="social-row"><span class="site-label">BS</span><a id="link-bluesky" class="social hidden" href="#" target="_blank" rel="noopener"></a></div>
                        <div class="social-row"><span class="site-label">PF</span><a id="link-portfolio" class="social hidden" href="#" target="_blank" rel="noopener"></a></div>
                    </div>
                    <div id="preview-controls" class="dev-controls">
                        <div class="control-title">Preview size</div>
                        <div class="control-row">
                            <label for="slider-vh">Alt. máx (vh)</label>
                            <input type="range" id="slider-vh" min="10" max="80" step="1">
                            <span id="value-vh" class="control-val"></span>
                        </div>
                        <div class="control-row">
                            <label for="slider-vw">Anch. máx (vw)</label>
                            <input type="range" id="slider-vw" min="10" max="80" step="1">
                            <span id="value-vw" class="control-val"></span>
                        </div>
                    </div>
                </div>
                <img id="user-image" class="hidden" />
            </div>
        </div>
    </div>
    <script src="app.js"></script>
        <script>
        // Ajuste automático de velocidades del marquee según ancho de texto/área visible
        (function(){
            function restartAnimation(el){
                // Reinicia la animación para aplicar nuevos tiempos sin saltos
                const name = getComputedStyle(el).animationName;
                el.style.animationName = 'none';
                // forzar reflow
                void el.offsetWidth;
                el.style.animationName = name;
            }
            function setupLane(lane){
                const scroll = lane.querySelector('.scroll');
                if (!scroll) return;
                const contents = scroll.querySelectorAll('.content');
                // Asegurar duplicación: 2 copias para bucle continuo
                if (contents.length === 1) {
                    scroll.appendChild(contents[0].cloneNode(true));
                }
                // Forzar medición tras layout
                const host = lane.closest('.loader-logo');
                const hostWidth = host ? host.clientWidth : lane.clientWidth;
                // Medir ancho de una copia
                const first = scroll.querySelector('.content');
                const copyWidth = first ? Math.ceil(first.getBoundingClientRect().width) : 0;
                // Definir distancia en px a recorrer por ciclo (una copia completa)
                const pxDist = Math.max(0, copyWidth);
                scroll.style.setProperty('--pxDist', pxDist + 'px');
                // Velocidad legible: píxeles por segundo
                const pps = 20; // píxeles por segundo (velocidad lecturable objetivo)
                // Duración de un ciclo: recorrer exactamente una copia
                const durSec = Math.max(6, pxDist / pps); // mínimo 6s para estabilidad
                scroll.style.animationDuration = durSec.toFixed(2) + 's';
                restartAnimation(scroll);
            }
            async function setupAll(){
                // Esperar a que carguen las fuentes para medir el ancho correcto
                try {
                    if (document.fonts && document.fonts.ready) {
                        await document.fonts.ready;
                    }
                } catch {}
                document.querySelectorAll('#loading-screen .word-lane').forEach(setupLane);
                // Reajuste posterior por si hay pequeños cambios de layout
                setTimeout(() => document.querySelectorAll('#loading-screen .word-lane').forEach(setupLane), 250);
            }
            // Ejecutar al cargar fuentes/DOM
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                requestAnimationFrame(setupAll);
            } else {
                document.addEventListener('DOMContentLoaded', () => requestAnimationFrame(setupAll));
            }
            // Recalcular en resize para mantener la fluidez
            window.addEventListener('resize', () => { requestAnimationFrame(setupAll); });
        })();
        // Pre-carga + barra de progreso con bloqueo hasta 100% (máx 5s) y botón Start
        (function(){
            const loadingEl = document.getElementById('loading-screen');
            const progressLine = document.getElementById('progress-line');
            const loaderText = document.getElementById('loader-text');
            const startBtn = document.getElementById('loader-start');
            let unlocked = false;

            function setProgress(p){
                const pct = Math.max(0, Math.min(100, Math.floor(p)));
                if (progressLine) progressLine.style.width = pct + '%';
            }
            function unlock(){
                if (unlocked) return;
                unlocked = true;
                // Cambiar texto a Start y mostrar botón
                if (loaderText) loaderText.textContent = '';
                const frame = document.querySelector('.loader-text-frame');
                if (frame) frame.classList.add('hidden');
                if (startBtn) startBtn.classList.remove('hidden');
                // Habilitar click en Start para cerrar
                startBtn?.addEventListener('click', () => {
                    loadingEl?.classList.add('hidden');
                }, { once: true });
            }
            // Helper: carga una lista de URLs en paralelo
            function preloadImages(urls = []){
                const uniq = Array.from(new Set(urls.filter(Boolean)));
                return Promise.allSettled(uniq.map(u => new Promise((resolve) => {
                    const im = new Image();
                    im.decoding = 'async';
                    im.referrerPolicy = 'no-referrer';
                    im.onload = () => resolve({ ok:true, url:u });
                    im.onerror = () => resolve({ ok:false, url:u });
                    im.src = u;
                })));
            }
            // Construir lista prioritaria: sprites de personajes desde segmentos.json
            async function gatherCriticalAssets(){
                const list = [];
                try {
                    const res = await fetch('assets/segmentos/segmentos.json', { cache: 'no-cache' });
                    const segs = await res.json();
                    // priorizar sprites (imagen)
                    for (const s of segs) {
                        if (!s) continue;
                        let img = (s.imagen||'').toString().replace(/\\/g,'/');
                        if (img && !/^https?:\/\//i.test(img)) {
                            const f = img.split('/').pop();
                            img = 'assets/segmentos/' + f;
                        }
                        if (img) list.push(img);
                    }
                    // opcional: pre-cargar divisores y UI importantes
                    list.push(
                        'assets/ui/PNG/Madera/Default/divider.png',
                        'assets/ui/PNG/Madera/Default/divider_edges.png',
                        'assets/ui/PNG/Madera/Default/button_rectangle_line.png',
                        'assets/ui/PNG/Madera/Default/input_outline_rectangle.png',
                        'assets/ui/PNG/Madera/Default/icon_cross.png',
                        'assets/ui/PNG/Madera/Default/icon_outline_cross.png'
                    );
                } catch {}
                return list;
            }

            async function startPreload(){
                const assets = await gatherCriticalAssets();
                // Lanzar precarga en segundo plano (no bloquea el desbloqueo por tiempo)
                preloadImages(assets).catch(() => {});
                // Barra de tiempo: 0 → 100% en máx 5s
                const MAX_MS = 5000;
                const t0 = performance.now();
                let rafId = 0;
                const tick = (now) => {
                    const t = Math.min(1, (now - t0) / MAX_MS);
                    setProgress(t * 100);
                    if (t < 1) {
                        rafId = requestAnimationFrame(tick);
                    } else {
                        cancelAnimationFrame(rafId);
                        setProgress(100);
                        unlock();
                    }
                };
                rafId = requestAnimationFrame(tick);
            }
            // iniciar cuanto antes
            startPreload();
        })();
        // Simple SFX manager using assets/ui/Sounds (with autoplay priming)
        (function(){
            const enabled = true;
            const VOLUME_MULT = 0.8; // reduce all volumes by 20%
            const sounds = {
                clickA: 'assets/ui/Sounds/click-a.ogg',
                clickB: 'assets/ui/Sounds/click-b.ogg',
                switchA: 'assets/ui/Sounds/switch-a.ogg',
                switchB: 'assets/ui/Sounds/switch-b.ogg',
                tapA: 'assets/ui/Sounds/tap-a.ogg',
                tapB: 'assets/ui/Sounds/tap-b.ogg'
            };
            const pool = new Map();
            let primed = false;

            async function primeOnce() {
                if (primed) return; // avoid re-priming
                primed = true;
                // Create at least one muted element per source and attempt muted autoplay
                const entries = Object.values(sounds);
                await Promise.all(entries.map(async (src) => {
                    try {
                        let list = pool.get(src);
                        if (!list) { list = []; pool.set(src, list); }
                        const a = new Audio(src);
                        a.preload = 'auto';
                        a.muted = true; // muted autoplay is allowed in most browsers
                        a.volume = 0;
                        a.loop = false;
                        a.playsInline = true;
                        // Attempt to play briefly, then pause and unmute for later use
                        await a.play().catch(() => {});
                        setTimeout(() => { try { a.pause(); a.currentTime = 0; a.muted = false; } catch {} }, 150);
                        list.push(a);
                    } catch {}
                }));
            }

            function ensureListFor(src) {
                let list = pool.get(src);
                if (!list) { list = []; pool.set(src, list); }
                return list;
            }

            function play(key, volume=0.35) {
                if (!enabled) return;
                const src = sounds[key];
                if (!src) return;
                const list = ensureListFor(src);
                let a = list.find(x => x.paused);
                if (!a) {
                    a = new Audio(src);
                    a.preload = 'auto';
                    a.playsInline = true;
                    list.push(a);
                }
                const v = Math.max(0, Math.min(1, volume * VOLUME_MULT));
                try {
                    a.currentTime = 0;
                    a.volume = v;
                    const p = a.play();
                    if (p && typeof p.then === 'function') {
                        p.catch(() => {
                            // If blocked, try priming again (idempotent)
                            primed = false;
                            primeOnce();
                        });
                    }
                } catch {
                    primed = false;
                    primeOnce();
                }
            }

            // Try to prime as early as possible
            try { primeOnce(); } catch {}
            // Retry on visibility or first pointer move (no click required)
            document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') primeOnce(); });
            const onFirstPointerMove = () => { primeOnce(); document.removeEventListener('pointermove', onFirstPointerMove); };
            document.addEventListener('pointermove', onFirstPointerMove, { once: true });

            window.SFX = { play, forcePrime: primeOnce };
        })();
    // PFP volador: al clickear la imagen de PFP del panel, lanza esa misma PFP en parábola L→R o R→L
    (function() {
        function currentPfpSrc() {
            const el = document.getElementById('pfp-image');
            if (!el) return null;
            const src = el.getAttribute('src') || '';
            // ignorar placeholder transparente u origen vacío
            if (!src || /^data:image\/gif/i.test(src)) return null;
            return src;
        }
        function pickPfpSrc() {
            try {
                // Priorizar el PFP actualmente mostrado en el panel
                const cur = currentPfpSrc();
                if (cur) return cur;
                const segs = Array.isArray(window.segmentos) ? window.segmentos : [];
                // Si hay selección/hover actual, priorizar su PFP
                if (Number.isInteger(window.currentIdx) && segs[window.currentIdx]) {
                    const v = segs[window.currentIdx].perfil;
                    if (v && v !== '-' && String(v).trim()) {
                        let p = String(v).replace(/\\\\/g,'/').replace(/^\/*/,'');
                        if (!/^https?:\/\//i.test(p) && !p.startsWith('assets/')) {
                            if (p.startsWith('pfp_web/')) p = 'assets/' + p;
                            else if (p.startsWith('pfp/')) p = 'assets/' + p;
                            else p = 'assets/pfp_web/' + p.split('/').pop();
                        }
                        return p;
                    }
                }
                // Fallback: cualquiera con PFP
                const candidates = segs.map(s => (s && s.perfil) ? String(s.perfil).replace(/\\\\/g,'/').replace(/^\/*/,'') : null)
                    .filter(v => v && v !== '-' && !/\s*$/.test(v));
                if (candidates.length === 0) return null;
                let pick = candidates[Math.floor(Math.random() * candidates.length)];
                if (!/^https?:\/\//i.test(pick) && !pick.startsWith('assets/')) {
                    if (pick.startsWith('pfp_web/')) pick = 'assets/' + pick;
                    else if (pick.startsWith('pfp/')) pick = 'assets/' + pick;
                    else pick = 'assets/pfp_web/' + pick.split('/').pop();
                }
                return pick;
            } catch { return null; }
        }
        function launchFlyer(fromLeft = Math.random() < 0.5) {
            const src = pickPfpSrc();
            if (!src) return;
            const img = document.createElement('img');
            img.className = 'pfp-flyer';
            // iniciar justo fuera de la pantalla por la izquierda o derecha
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const startX = fromLeft ? -100 : vw + 100;
            const endX = fromLeft ? vw + 120 : -120;
            // Rango vertical ampliado para mayor variedad de parábolas
            const startY = Math.floor(vh * (0.02 + Math.random() * 0.58)); // 2-60% altura
            const apexY = Math.floor(vh * (0.00 + Math.random() * 0.32));  // 0-32% (pico alto)
            const endY  = Math.floor(vh * (0.40 + Math.random() * 0.55));  // 40-95%
            const rotDir = fromLeft ? 1 : -1;
            const duration = 3200 + Math.floor(Math.random() * 1200); // 3.2s - 4.4s
            const startTime = performance.now();
            // Posición controlada únicamente por transform para evitar offset doble
            img.style.left = '0px';
            img.style.top = '0px';
            img.style.transform = `translate3d(${startX}px, ${startY}px, 0) rotate(0deg)`;

            // precarga para evitar flash roto
            const pre = new Image();
            pre.onload = () => {
                img.src = pre.src;
                document.body.appendChild(img);
                requestAnimationFrame(tick);
            };
            pre.onerror = () => {/* omitir si falla */};
            pre.src = src;

            function parabola(t) {
                // Interpolación paramétrica con un vértice (apex) y extremos (start, end)
                // Lerp X lineal, Y describe parábola con apex
                const x = startX + (endX - startX) * t;
                // Usar parábola a través de (0,startY), (0.5,apexY), (1,endY)
                // y(t) = a t^2 + b t + c, con c = startY
                const c = startY;
                const b = 4*apexY - endY - 3*startY;
                const a = endY - b - c;
                const y = a*t*t + b*t + c;
                return { x, y };
            }
            function tick(now) {
                const elapsed = now - startTime;
                const t = Math.min(1, elapsed / duration);
                const p = parabola(t);
                const rot = (t * 720 * rotDir); // 2 vueltas
                img.style.transform = `translate3d(${Math.round(p.x)}px, ${Math.round(p.y)}px, 0) rotate(${rot.toFixed(1)}deg)`;
                // remover si salió por completo
                if (t >= 1 || p.x < -160 || p.x > (vw + 160) || p.y < -160 || p.y > (vh + 160)) {
                    img.remove();
                    return;
                }
                requestAnimationFrame(tick);
            }
        }
        // esperar a que app.js cargue los segmentos globales
        function ready() {
            return Array.isArray(window.segmentos) && window.segmentos.length > 0;
        }
        // Trigger: click en la imagen de PFP del panel de información
        function bindTrigger() {
            const pfp = document.getElementById('pfp-image');
            if (!pfp) return;
            pfp.addEventListener('click', () => {
                // alternar dirección aleatoriamente
                window.SFX?.play('tapA', 0.35);
                launchFlyer(Math.random() < 0.5);
            });
        }
        if (ready()) bindTrigger();
        else {
            const id = setInterval(() => {
                if (ready()) { clearInterval(id); bindTrigger(); }
            }, 300);
        }
    })();
    // Close button + Esc support
    (function(){
        const btn = document.getElementById('panel-close');
        function closePanel(){
            // mimic clicking outside: unlock and hide (same path)
            document.dispatchEvent(new CustomEvent('ui:close-panel'));
        }
        if (btn) btn.addEventListener('click', closePanel);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closePanel();
        });
    })();
    // Debug overlay for main screen and info panel: enable with ?debug=1 or toggle via Ctrl/Alt + D
    (function(){
        const info = document.getElementById('info-panel');
        const params = new URLSearchParams(window.location.search);
        const initial = params.get('debug');
        const enable = (initial === '1' || initial === 'true');
        if (enable) {
            document.body.classList.add('debug');
            info?.classList.add('debug');
        }
        document.addEventListener('keydown', (e) => {
            if ((e.key === 'd' || e.key === 'D') && (e.ctrlKey || e.altKey)) {
                const on = !document.body.classList.contains('debug');
                document.body.classList.toggle('debug', on);
                if (info) info.classList.toggle('debug', on);
                e.preventDefault();
            }
        });
    })();
    </script>
</body>
</html>
